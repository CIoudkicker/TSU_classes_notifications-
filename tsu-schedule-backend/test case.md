# Тестовый пример 1: проверка соединения Kafka

## тестовая цель
Убедитесь, что приложение Node.js может установить подключение к кластеру Kafka в Docker.

## предпосылки
- Кластер Kafka развернут и запущен в Docker.
- В приложении Node.js установлена ​​необходимая клиентская библиотека Kafka.

## Тестовые шаги

1. Настройте параметры подключения Kafka:
    - Введите адрес, порт и другие связанные конфигурации кластера Kafka.
    - Установите группу потребителей приложения и тему.

2. Установите соединение:
    - Подключитесь к кластеру Kafka с помощью клиентской библиотеки Kafka.

3. Отправьте тестовое сообщение:
    - Создайте тестовое сообщение.
    - Используйте интерфейс производителя для отправки тестовых сообщений в указанную тему Kafka.

4. Получите и проверьте сообщение:
    - Подключитесь к той же теме Kafka, используя потребительский интерфейс.
    - Получите только что отправленное тестовое сообщение.
    - Убедитесь, что содержимое полученного сообщения соответствует содержанию отправленного сообщения.

## ожидаемый результат
- Приложение Node.js может успешно подключиться к кластеру Kafka.
- Тестовые сообщения могут быть успешно отправлены в указанную тему Kafka.
- Содержание полученного сообщения соответствует содержанию отправленного сообщения.

## Примечание
- Если ожидаемый результат соответствует ожидаемому, тест считается пройденным.
- В случае сбоя соединения, сбоя отправки или получения сообщения тест завершается неудачно.


# Тестовый пример 2: создание и потребление тестового сообщения

## Цель теста
Убедиться, что приложение Node.js может правильно создавать и использовать сообщения.

## Предпосылки
- Кластер Kafka правильно развернут и работает в среде Docker.
- В приложении Node.js установлена ​​соответствующая клиентская библиотека Kafka.

## Шаги теста

1. Создайте производителя:
   - Создайте производителя в приложении Node.js с помощью клиентской библиотеки Kafka.
   - Настройте параметры производителя, включая адрес кластера Kafka, тему и т.д.

2. Отправить сообщение:
   - Отправляйте несколько сообщений в указанную тему Kafka, используя интерфейс производителя.
   - Сообщение может быть любого содержания и используется для проверки нормальности функции отправки сообщения.

3. Создайте потребителя:
   - Создайте потребителя в том же или другом приложении Node.js, используя клиентскую библиотеку Kafka.
   - Настройте параметры потребителя, включая адрес кластера Kafka, тему и т.д.

4. Получите и проверьте сообщение:
   - Потребители получают сообщения из тем Kafka.
   - Убедитесь, что содержимое и последовательность полученного сообщения соответствуют отправленному сообщению.
   - Убедитесь, что все отправленные сообщения успешно получены.

## Ожидаемый результат
- Приложение Node.js может правильно создавать и использовать сообщения Kafka.
- Все отправленные сообщения могут быть успешно получены, а содержание и порядок остаются такими же, как и при отправке.

## Примечание
- Если ожидаемый результат соответствует ожидаемому, тест считается пройденным.
- Если сообщение не может быть отправлено или получено или содержимое полученного сообщения не соответствует отправленному сообщению, тест завершается неудачно.





# Тестовый пример 3: тест производительности

## тестовая цель
Оцените производительность приложений Node.js под нагрузкой Kafka.

## предпосылки
- Кластер Kafka правильно развернут и работает в среде Docker.
- В приложении Node.js установлена ​​соответствующая клиентская библиотека Kafka.
- Установлены и настроены инструменты тестирования производительности (такие как Apache JMeter, Gatling и т.д.).

## Тестовые шаги

### Подготовьте среду тестирования производительности:
1. Настройте инструмент тестирования производительности для имитации создания и потребления большого количества одновременных сообщений.
2. Установите параметры теста, включая количество одновременных сообщений, продолжительность, размер сообщения и т. д.

### Запустить тесты производительности:
1. Запустите инструмент тестирования производительности и начните моделировать операции производства и потребления параллельных сообщений.
2. Во время теста записывайте ключевые показатели производительности, такие как время отклика, пропускная способность и задержка.

### Увеличение или уменьшение количества одновременных сообщений:
1. Измените параметры теста производительности, чтобы увеличить или уменьшить количество одновременных сообщений.
2. Наблюдайте за изменениями производительности приложений Node.js, включая изменения таких показателей, как время отклика, пропускная способность и задержка.

### Анализ результатов теста производительности:
1. По результатам теста производительности оцените производительность приложения Node.js под нагрузкой Kafka.
2. Определите узкие места в производительности, например, были ли достигнуты пределы системных ресурсов.
3. При необходимости выполните оптимизацию и настройку производительности.

## ожидаемый результат
- Приложения Node.js способны поддерживать стабильную производительность под нагрузкой Kafka.
- Ключевые показатели производительности, такие как время отклика, пропускная способность и задержка, соответствуют ожиданиям.
- Приложение адаптируется и демонстрирует разумные изменения производительности при увеличении или уменьшении количества одновременных сообщений.

## Примечание
- Если ожидаемый результат соответствует ожидаемому, тест считается пройденным.
- Если приложение работает нестабильно под нагрузкой, не соответствует ключевым показателям или не может адаптироваться к изменениям в параллельных сообщениях, тест завершается неудачно.





# Тестовый пример 4: процесс запуска Kafka в Docker Compose

**Тестовая цель:**
Убедитесь, что Kafka может успешно подключиться к службе ZooKeeper во время запуска, и проверьте наличие ошибок во время запуска.

**Предпосылки:**
- Сервер Kafka, развернутый с помощью Docker Compose, правильно установлен и настроен.

**Этапы проверки:**

1. Запустите сервер Kafka.
2. Убедитесь, что Kafka успешно загрузила файл конфигурации.
3. Проверьте, может ли Kafka подключиться к службе ZooKeeper.

**ожидаемый результат:**

Шаг 1: Сервер Kafka успешно запущен.
Шаг 2: Kafka успешно загрузила файл конфигурации.
Шаг 3: Kafka успешно подключается к службе ZooKeeper.

**Примечание:**
Если ожидаемый результат соответствует ожидаемому, тест считается пройденным.
Если шаг 2 или шаг 3 не пройден, тест не пройден.



# Тестовый пример интерфейса 5  login

## прецедент

### 1. Проверка действительных учетных данных

1. Отправьте запрос POST на URL-адрес API входа в систему (например: `http://localhost:5500/api/login`).
2. Установите Content-Type в application/json в заголовке запроса.
3. Укажите действительные учетные данные в теле запроса, например:
  ```json
   {
     "email": "admin",
     "password": "password"
   }
 ```
- Убедитесь, что код состояния ответа — 200 OK.
- Убедитесь, что в тексте ответа существует поле с именем token.
- Проверьте другие поля ответа или возвращенной информации, например, информацию о пользователе и т. д.

## 2. Проверка на наличие недействительных учетных данных

- Отправьте запрос POST на URL-адрес API входа.
- Установите Content-Type в application/json в заголовке запроса.
- Укажите неверные учетные данные в теле запроса, например неправильный адрес электронной почты или пароль.
- Убедитесь, что код состояния ответа равен 500.
- Проверьте сообщение об ошибке в теле ответа, чтобы убедиться, что оно указывает на сбой аутентификации.

## 3. Проверьте отсутствие обязательных полей

- Отправьте запрос POST на URL-адрес API входа.
- Установите Content-Type в application/json в заголовке запроса.
- Отсутствие одного или нескольких обязательных полей в тексте запроса, таких как отсутствующие поля электронной почты или пароля.
- Убедитесь, что код состояния ответа равен 500.
- Проверьте сообщение об ошибке в тексте ответа, чтобы убедиться, что оно указывает на отсутствие обязательного поля.




## Тестовый пример интерфейса 6 showSchedule

Цель тестирования: проверка поведения и результатов функции showSchedule в различных сценариях.

Предварительные условия:
Пользователь успешно авторизован и имеет действительный токен доступа.

### Получение информации о расписании в нормальном режиме:

1. Отправить GET-запрос на эндпоинт `/api/getSchedulestat`, предоставив действительный токен доступа.
2. Ожидаемый результат:
   - Код ответа 200 OK.
   - В теле ответа содержится правильная информация о расписании.

### Недействительный токен доступа:

1. Отправить GET-запрос на эндпоинт `/api/getSchedulestat`, предоставив недействительный токен доступа.
2. Ожидаемый результат:
   - Код ответа 401 Unauthorized.
   - В теле ответа содержится сообщение об ошибке, указывающее на неавторизованный доступ.

### Запрос в неавторизованном состоянии:

1. Отправить GET-запрос на эндпоинт `/api/getSchedulestat` без предоставления токена доступа.
2. Ожидаемый результат:
   - Код ответа 401 Unauthorized.
   - В теле ответа содержится сообщение об ошибке, указывающее на неавторизованный доступ.

### Аномальная ситуация: сбой сети:

1. Разорвать соединение сети или выключить сервер.
2. Отправить GET-запрос на эндпоинт `/api/getSchedulestat`, предоставив действительный токен доступа.
3. Ожидаемый результат:
   - Время ожидания запроса истекло или произошла ошибка соединения.
   - Ответ не получен.
